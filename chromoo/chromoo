#!/usr/bin/env python

"""
    @name: chromoo
    @deps: pymoo==0.5
    @desc: optimizes things
"""

# NOTE: https://stackoverflow.com/questions/65191621/using-vectorized-evaluation-of-pymoo-to-solve-a-multi-objective-problem-throwing
#
# TODO: Move to git
# TODO: Abstractify
# TODO: Parallelize
# TODO: Use temp files for parallelizability
# TODO: Fix time sections ka jhol

import struct
import random
import string
import copy

from functools import partial
from multiprocessing import Pool

import argparse

from cadet import Cadet

import subprocess

from pymoo.algorithms.moo.nsga3 import NSGA3
from pymoo.algorithms.moo.nsga2 import NSGA2

from pymoo.factory import get_sampling, get_crossover, get_mutation
from pymoo.factory import get_problem, get_reference_directions

from pymoo.optimize import minimize
from pymoo.core.problem import ElementwiseProblem, Problem

from scipy.interpolate import interp1d

import matplotlib.pyplot as plt

cadetpath = subprocess.run(['which', 'cadet-cli'], capture_output=True, text=True ).stdout.strip()
Cadet.cadet_path = cadetpath

def readChromatogram(data_path):
    time= []
    conc= []
    delimiter = ' '
    with open(data_path, newline='') as csvfile:
        if ',' in csvfile.readline():
            delimiter = ','
    with open(data_path, newline='') as csvfile:
        # data = list(csv.reader(csvfile))
        for line in csvfile:
            data_line = line.strip().split(delimiter)
            data_line = list(filter(None, data_line))
            if (data_line != []):
                time.append(float(data_line[0]))
                conc.append(float(data_line[1]))
    return time, conc

def dataformatsize(dataformat):
    vartype = dataformat[1]
    datasize = 0
    if vartype == 'd':
        datasize = 8
    elif vartype == 'f':
        datasize = 4
    elif vartype == 'i':
        datasize = 4
    return datasize

def bin_to_arr(filename, dataformat, skip=0, skiprows=0, nrows=0, ncols=0):
    datasize = dataformatsize(dataformat)

    with(open(filename, 'rb')) as input:
        input.seek(skip * nrows * ncols * datasize + skiprows * ncols * datasize, 0)
        myiter = struct.iter_unpack(dataformat, input.read())

        arr = []
        for i in myiter:
            arr.append(i[0])

        return arr

def loadh5(filename):

    sim = Cadet()
    sim.filename = filename
    sim.load()

    return sim

# TODO: This should take dicts
def update(sim, path_parameters, values):
    # path_obj = sim.root
    # splitarr = path_parameter.split('/')
    # for key in splitarr:
    #     path_obj = path_obj[key]
    #
    # path_obj = values[0]

    # TODO:
    sim.root.input.model.unit_002.col_dispersion = values[0]
    sim.root.input.model.unit_002.col_dispersion_radial = values[1]

    sim.save()

    runout = sim.run()
    if runout.returncode != 0:
        print(runout)
        raise RuntimeError
    sim.load()


def driver(filename, ref_curve):

    # # TODO: Understand this
    # ref_dirs = get_reference_directions("das-dennis", 1, n_partitions=20)

    populationSize = 20
    numRefDirs = populationSize
    ref_dirs = get_reference_directions("energy", 1, numRefDirs, seed=1)

    algorithm = NSGA3(pop_size=populationSize, ref_dirs=ref_dirs)

    # algorithm = NSGA2(
    #     pop_size=50,
    #     n_offsprings=10,
    #     sampling=get_sampling("real_random"),
    #     crossover=get_crossover("real_sbx", prob=0.9, eta=15),
    #     mutation=get_mutation("real_pm", eta=20),
    #     eliminate_duplicates=True
    # )

    problem = grm2d(filename, ref_curve)

    res = minimize(
            problem, 
            algorithm,
            seed=122,
            termination=('n_gen', 10), 
            verbose=True
    )

    print(f"Took {res.exec_time} seconds to terminate.")
    print(f"Fitted Dispersion: {res.X}")
    print(f"SSE: {res.F}")

    return res.X


def sse2(x0, y0, x, y):
    """
    Sum of squares of errors
    x0, y0 are reference values
    x, y are to be measured against x0, y0
    """
    # Interpolate reference data (x0,y0) onto new x grid
    f = interp1d(x0, y0)
    y0new = f(x)

    sse_value = sum([(n1 - n2)**2 for n1, n2 in zip(y, y0new)])
    return sse_value

def evaluate_sim(sim, t0, c0, path_parameters, x):
    print(x)
    newsim = copy.deepcopy(sim)
    newsim.filename = 'temp' + ''.join(random.choices(string.ascii_uppercase + string.ascii_lowercase + string.digits, k=6)) + '.h5'

    update(newsim, path_parameters, x)

    t = newsim.root.output.solution.solution_times
    c = newsim.root.output.solution.unit_003.solution_outlet_comp_000

    sse_value = sse2(t0,c0, t,c)
    return [sse_value]

class simple(Problem):

    def __init__(self, filename, ref_curve_csv):
        super().__init__(n_var=1, n_obj=1, n_constr=0, xl=[1.0e-9], xu=[1.0e-4])
        self.sim = loadh5(filename)
        self.t0, self.c0 = readChromatogram(ref_curve_csv)

    def _evaluate(self, x, out, *args, **kwargs):

        with Pool(4) as pool:
            parfunc = partial(evaluate_sim, self.sim, self.t0, self.c0, [])
            out["F"] = pool.map(parfunc, x)

class grm2d(Problem):
    def __init__(self, filename, ref_curve_csv):
        super().__init__(n_var=2, n_obj=1, n_constr=0, xl=[1.0e-9], xu=[1.0e-4])
        self.sim = loadh5(filename)
        self.t0, self.c0 = readChromatogram(ref_curve_csv)

    def _evaluate(self, x, out, *args, **kwargs):

        with Pool(4) as pool:
            parfunc = partial(evaluate_sim, self.sim, self.t0, self.c0, [])
            out["F"] = pool.map(parfunc, x)


def create_h5_template(filename):
    """
    should:
        - load file
        - modify section times to match the ends of the csv data
        - modify simulation times to match
    """

    sim = loadh5(filename)

    t0, _ = readChromatogram("chromatogram-corrected.csv")

    ## NOTE: Adjust h5 times to use CSV times
    sim.root.input.solver.sections.section_times = [min(t0), max(t0)]
    sim.root.input.solver.user_solution_times = t0

    template_filename = f"{filename}_template.h5"
    sim.filename = template_filename
    sim.save()
    return template_filename

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("file", nargs=1, help="Simulation file")
    ap.add_argument('-r', '--reference', help="Reference file to fit to")
    args = vars(ap.parse_args())

    template_filename = create_h5_template(args['file'][0])
    out = driver(template_filename, args['reference'])
    sim = loadh5(template_filename)
    sim.filename = 'final.h5'

    update(sim, None, out)

    with plt.style.context(['science']):
        fig, ax = plt.subplots()
        t0, c0 = readChromatogram("chromatogram-corrected.csv")
        sim = loadh5("final.h5")
        t1 = sim.root.output.solution.solution_times
        c1 = sim.root.output.solution.unit_003.solution_outlet_comp_000
        ax.plot(t0,c0, lw=1, ls='solid', label='reference')
        ax.plot(t1,c1, lw=1, ls='dashed', label='result')
        fig.savefig("chromoo_result.pdf")

if __name__ == "__main__":
    main()
