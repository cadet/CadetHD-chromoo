#!/usr/bin/env python3

from rich import print
import corner
from chromoo.cadetSimulation import CadetSimulation

import numpy as np
import pandas as pd
from scipy import stats
import multiprocessing as mp
from functools import partial

from pathlib import Path

import argparse

from chromoo import ConfigHandler
from chromoo.simulation import run_sim_iter
from chromoo.utils import deep_get, readArray, readChromatogram
from chromoo.plotter import Plotter, Subplotter

from mpl_toolkits.axes_grid.inset_locator import InsetPosition

from matplotlib import pyplot as plt
import matplotlib as mpl 

pd.set_option('display.float_format', lambda x: '%e' % x)
pd.set_option('display.max_columns', None)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('config', help='config file to parse and process.')
    ap.add_argument('-n', default=1, type=int, help='Number of best simulations to run')
    ap.add_argument('--nproc', type=int, help='Number of processes to use to run simulations')
    ap.add_argument('-m', '--mean', choices=['geometric', 'arithmetic', 'rms'], default='rms', help='Mode of averaging scores')
    ap.add_argument('--csv', help='CSV file to process')
    ap.add_argument('--combine-port-breakthroughs', type=int, help='Combine breakthroughs of individual ports for this unit op.')
    ap.add_argument('--hist', default=20, help='Number of bins in histogram plot')
    ap.add_argument('--opts-overlay', help='Overlay all opts outputs and reference values')
    ap.add_argument('--plot-obj-par', action='store_true', help='plot objectives vs parameters')
    ap.add_argument('--corner', action='store_true', help='plot corner plots')

    ap.add_argument('--pop', action='store_true', help='Use pickled population database')
    ap.add_argument('--opt', action='store_true', help='Use pickled opt database')

    args = ap.parse_args()

    config = ConfigHandler()
    config.read(args.config)
    config.load()
    config.construct_simulation()

    postdir = Path('post') 
    postdir.mkdir(exist_ok=True)

    nproc = args.nproc or config.nproc

    if args.csv: 
        df_opt = pd.read_csv(args.csv)
        df_opt = calculate_mean(df_opt, args.mean, config.objective_names)
        df_opt = df_opt.sort_values(by=[args.mean])

        with Plotter(title=args.mean+' mean') as hist_plot: 
            hist_plot.hist(df_opt[args.mean], args.hist)
            hist_plot.save(postdir / f'histogram_{args.mean}_mean', dpi=300)

        columns = list(df_opt.columns[0:config.n_par])
        columns.append(df_opt.columns[-1])

        print("Best opts solution: ")
        best = df_opt[columns].iloc[0:args.n]
        df_pars_reversed = df_opt[df_opt.columns[0:config.n_par]].iloc[::-1]
        print(best)

        # TODO: Implement drawing bounds of parameters
        parameter_violin(df_pars_reversed, args, config, postdir)

        with mp.Pool(nproc) as pool:
            out = pool.map( 
                partial(run_sim_iter, 
                    sim=config.simulation, 
                    parameters=config.parameters, 
                    name=f'opts_final_{args.mean}', 
                    tempdir=postdir, 
                    store=True), 
                enumerate(best.values))

        for i,sim in enumerate(out):
            with Plotter(title='Simulation vs Reference', cmap='tab20', xlabel='x axis', ylabel='y axis') as obj_ref_plot: 
                for obj in config.objectives:
                    obj.plot(sim, obj_ref_plot)

                inset_ax = obj_ref_plot.fig.add_axes([0,0,1,1])
                ip = InsetPosition(obj_ref_plot.ax, [0.05,0.8,0.25,0.15])
                inset_ax.set_axes_locator(ip)
                # inset_ax.axis('off')
                inset_ax.get_xaxis().set_visible(False)
                inset_ax.get_yaxis().set_visible(False)
                inset_ax.bar(range(config.n_par), best[best.columns[0:config.n_par]].iloc[i].values)
                inset_ax.set(yscale='log')

                obj_ref_plot.save(f"{str(postdir)}/objectives_reference_{args.mean}_final_{i:03d}", dpi=300)


        # When using 2D GRM, use this to output the combined chromatogram at
        # the end of the unit without relying on an OUTLET unit op.
        if args.combine_port_breakthroughs is not None:
            t0 = config.objectives[0].x0
            for i,sim in enumerate(out): 
                sim = CadetSimulation(sim.root)
                arr = sim.combine_port_breakthroughs(args.combine_port_breakthroughs)
                np.savetxt(postdir / f'combined_breakthrough_opt_{i}.csv', np.stack([t0, arr], axis=1))

        if args.corner: 
            corner_plot_par = corner.corner(
                    np.log10(df_opt[config.parameter_names]),
                    labels=config.parameter_names,
                    show_titles=True
                    )
            corner_plot_par.savefig(postdir / 'corner_opt_par.pdf')

            corner_plot_obj = corner.corner(
                    np.log10(df_opt[config.objective_names]),
                    labels=config.objective_names,
                    show_titles=True
                    )
            corner_plot_obj.savefig(postdir / 'corner_opt_obj.pdf')


    if args.pop: 
        print("Reading pickled populations file...")
        populations = pd.read_pickle('populations')
        populations = populations.apply(pd.to_numeric)
        populations = calculate_mean(populations, args.mean, config.objective_names)

        # for i in range(populations['generation'].max()): 
        #     cur_gen = populations[populations['generation'] == i+1].to_numpy()
        #     np.savetxt(f'pop_gen_{i}.csv', cur_gen, delimiter=',')

        # minned = populations.loc[populations.groupby(['generation'])[args.mean].idxmin()]
        best_mean_score_per_gen = populations.groupby(['generation'])[args.mean].min()
        median_mean_score_per_gen = populations.groupby(['generation'])[args.mean].median()
        worst_mean_score_per_gen = populations.groupby(['generation'])[args.mean].max()

        best_mean_score_per_gen_plot = Plotter(title=f'Convergence', yscale='log', xlabel='Generations', ylabel=f'Meta-objective ({args.mean})')
        best_mean_score_per_gen_plot.plot(range(len(best_mean_score_per_gen)), best_mean_score_per_gen, label='best')
        best_mean_score_per_gen_plot.plot(range(len(median_mean_score_per_gen)), median_mean_score_per_gen, label='median')
        best_mean_score_per_gen_plot.plot(range(len(worst_mean_score_per_gen)), worst_mean_score_per_gen, label='worst')
        best_mean_score_per_gen_plot.legend('upper right', (1,1))
        best_mean_score_per_gen_plot.save(f'{str(postdir)}/best_{args.mean}_mean_per_gen', dpi=300)
        best_mean_score_per_gen_plot.close()

        # populations_best_score_ever_index = populations[args.mean].argmin()
        # print(populations.iloc[populations_best_score_ever_index])

        print("Best populations solution: ")
        df = populations.iloc[:,1:].sort_values(by=[args.mean]).drop_duplicates()
        best = df.iloc[0:args.n]
        print(best)

        if args.corner: 
            corner_plot_par = corner.corner(
                    np.log10(populations[config.parameter_names]),
                    labels=config.parameter_names,
                    show_titles=True
                    )
            corner_plot_par.savefig(postdir / 'corner_pop_par.pdf')

            corner_plot_obj = corner.corner(
                    np.log10(populations[config.objective_names]),
                    labels=config.objective_names,
                    show_titles=True
                    )
            corner.corner(
                    np.log10(df_opt[config.objective_names]),
                    labels=config.objective_names,
                    show_titles=True,
                    fig=corner_plot_obj, 
                    color='red'
                    )
            corner_plot_obj.savefig(postdir / 'corner_pop_obj.pdf')

        plot = Subplotter(
            nrows=config.n_obj,
            ncols=config.n_par,
            title='Objectives_Parameters',
            xscale='log',
            yscale='log'
        )

        gens = populations['generation'].to_numpy()
        nmax = max(gens)

        # cmap = mpl.cm.get_cmap(name=args['colormap'])
        cmap = mpl.cm.get_cmap(name='cool')
        if 'colors' in cmap.__dict__: 
            COLORS = cmap.colors
        else: 
            COLORS = [cmap(1.*i/(nmax-1)) for i in range(nmax)]

        FINAL_COLORS=list(map(lambda g: COLORS[g-1], gens))

        for i_obj, obj in enumerate(config.objective_names): 
            for i_par, par in enumerate(config.parameter_names): 

                x = populations[par]
                y = populations[obj]

                plot.scatter( 
                        x,y, 
                        i_obj, i_par, 
                        fontsize=7,
                        s=8,
                        c=FINAL_COLORS,
                        title=f'{config.parameter_names[i_par]} v {config.objective_names[i_obj]}' )
        plot.save(postdir / f"objectives_parameters", dpi=300)
        plot.close()

        if args.plot_obj_par: 
            # Plot the objectives_parameters plot individually
            for i_obj, obj in enumerate(config.objective_names): 
                for i_par, par in enumerate(config.parameter_names): 
                    plot = Plotter(title=f"{par} vs {obj}", xlabel=f"{par}", ylabel=f"{obj}", xscale='log', yscale='log')

                    x = populations[par]
                    y = populations[obj]

                    plot.scatter(x,y, )

                    plot.save(postdir / f"objectives_parameters_{obj}_{par}", dpi=300)
                    plot.close()


def calculate_mean(df, mean, columns):
    if mean == 'geometric': 
        df[mean] = stats.gmean(df[columns], axis=1)
    elif mean == 'arithmetic':
        df[mean] = df[columns].mean(axis=1)
    elif mean == 'rms':
        df[mean] = np.sqrt(np.square(df[columns]).mean(axis=1)) 

    return df

def parameter_violin(best_pars_reversed, args, config, postdir): 
    """
    Generate violin plots of all optimal parameters, joined by lines
    """
    # cmapname = 'YlOrRd'
    cmapname = 'cool'
    # npoints = len(best_pars_reversed)
    npoints = 1
    with Plotter('Parameter values', cmap=cmapname, n_total_curves=npoints, yscale='log') as parameters_violin: 
        violin_parts = parameters_violin.ax.violinplot(dataset = list(best_pars_reversed.to_numpy().T), positions=range(config.n_par))
        for pc in violin_parts['bodies']:
            pc.set_facecolor('blue')
            pc.set_edgecolor('black')
        for partname in ('cbars','cmins','cmaxes'):
            vp = violin_parts[partname]
            vp.set_edgecolor('black')
            vp.set_linewidth(1)
        for i in range(npoints): 
            parameters_violin.scatter(range(config.n_par), best_pars_reversed.to_numpy()[i], s=4 )
        # parameters_violin.ax.plot(range(config.n_par), list(best_pars_reversed.to_numpy().T))
        parameters_violin.ax.set_xticks(range(config.n_par))
        parameters_violin.ax.set_xticklabels(config.parameter_names, rotation=45, ha='right')
        parameters_violin.ax.minorticks_off()
        parameters_violin.save(postdir / 'parameters_violin', dpi=300)

        # # Normalizer
        # df_with_mean = calculate_mean(best_pars_reversed, args.mean, config.objective_names)
        # # vmin=df_with_mean.apply(pd.to_numeric).columns[-1].values
        # # vmax=df_with_mean.apply(pd.to_numeric).columns[-1]
        # vmin = df_with_mean.columns[arg.mean].values.min()
        # vmax = df_with_mean.columns[arg.mean].values.max()
        # print(vmin, vmax)
        # norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)
        #   
        # # creating ScalarMappable
        # sm = plt.cm.ScalarMappable(cmap=cmapname, norm=norm)
        # sm.set_array([])
        #   
        # plt.colorbar(sm, ticks=np.linspace(vmin, vmax, 4), format='%.2e')


if __name__=="__main__":
    main()
